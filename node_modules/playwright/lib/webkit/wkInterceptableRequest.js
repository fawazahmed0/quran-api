"use strict";
/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WKInterceptableRequest = void 0;
const helper_1 = require("../helper");
const network = require("../network");
const converters_1 = require("../converters");
const errorReasons = {
    'aborted': 'Cancellation',
    'accessdenied': 'AccessControl',
    'addressunreachable': 'General',
    'blockedbyclient': 'Cancellation',
    'blockedbyresponse': 'General',
    'connectionaborted': 'General',
    'connectionclosed': 'General',
    'connectionfailed': 'General',
    'connectionrefused': 'General',
    'connectionreset': 'General',
    'internetdisconnected': 'General',
    'namenotresolved': 'General',
    'timedout': 'Timeout',
    'failed': 'General',
};
class WKInterceptableRequest {
    constructor(session, allowInterception, frame, event, redirectedFrom, documentId) {
        this._interceptedCallback = () => { };
        this._session = session;
        this._requestId = event.requestId;
        this._allowInterception = allowInterception;
        const resourceType = event.type ? event.type.toLowerCase() : (redirectedFrom ? redirectedFrom.resourceType() : 'other');
        let postDataBuffer = null;
        if (event.request.postData)
            postDataBuffer = Buffer.from(event.request.postData, 'binary');
        this.request = new network.Request(allowInterception ? this : null, frame, redirectedFrom, documentId, event.request.url, resourceType, event.request.method, postDataBuffer, headersObject(event.request.headers));
        this._interceptedPromise = new Promise(f => this._interceptedCallback = f);
    }
    async abort(errorCode) {
        const errorType = errorReasons[errorCode];
        helper_1.assert(errorType, 'Unknown error code: ' + errorCode);
        await this._interceptedPromise;
        // In certain cases, protocol will return error if the request was already canceled
        // or the page was closed. We should tolerate these errors.
        await this._session.sendMayFail('Network.interceptRequestWithError', { requestId: this._requestId, errorType });
    }
    async fulfill(response) {
        await this._interceptedPromise;
        // In certain cases, protocol will return error if the request was already canceled
        // or the page was closed. We should tolerate these errors.
        let mimeType = response.isBase64 ? 'application/octet-stream' : 'text/plain';
        const headers = converters_1.headersArrayToObject(response.headers);
        const contentType = headers['content-type'];
        if (contentType)
            mimeType = contentType.split(';')[0].trim();
        await this._session.sendMayFail('Network.interceptRequestWithResponse', {
            requestId: this._requestId,
            status: response.status,
            statusText: network.STATUS_TEXTS[String(response.status)],
            mimeType,
            headers,
            base64Encoded: response.isBase64,
            content: response.body
        });
    }
    async continue(overrides) {
        await this._interceptedPromise;
        // In certain cases, protocol will return error if the request was already canceled
        // or the page was closed. We should tolerate these errors.
        await this._session.sendMayFail('Network.interceptWithRequest', {
            requestId: this._requestId,
            method: overrides.method,
            headers: overrides.headers ? converters_1.headersArrayToObject(overrides.headers) : undefined,
            postData: overrides.postData ? Buffer.from(overrides.postData).toString('base64') : undefined
        });
    }
    createResponse(responsePayload) {
        const getResponseBody = async () => {
            const response = await this._session.send('Network.getResponseBody', { requestId: this._requestId });
            return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');
        };
        return new network.Response(this.request, responsePayload.status, responsePayload.statusText, headersObject(responsePayload.headers), getResponseBody);
    }
}
exports.WKInterceptableRequest = WKInterceptableRequest;
function headersObject(headers) {
    const result = {};
    for (const key of Object.keys(headers))
        result[key.toLowerCase()] = headers[key];
    return result;
}
//# sourceMappingURL=wkInterceptableRequest.js.map