"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrameDispatcher = void 0;
const frames_1 = require("../../frames");
const dispatcher_1 = require("./dispatcher");
const elementHandlerDispatcher_1 = require("./elementHandlerDispatcher");
const jsHandleDispatcher_1 = require("./jsHandleDispatcher");
const networkDispatchers_1 = require("./networkDispatchers");
class FrameDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, frame) {
        super(scope, frame, 'Frame', {
            url: frame.url(),
            name: frame.name(),
            parentFrame: dispatcher_1.lookupNullableDispatcher(frame.parentFrame()),
            loadStates: Array.from(frame._subtreeLifecycleEvents),
        });
        this._frame = frame;
        frame._eventEmitter.on(frames_1.kAddLifecycleEvent, (event) => {
            this._dispatchEvent('loadstate', { add: event });
        });
        frame._eventEmitter.on(frames_1.kRemoveLifecycleEvent, (event) => {
            this._dispatchEvent('loadstate', { remove: event });
        });
        frame._eventEmitter.on(frames_1.kNavigationEvent, (event) => {
            const params = { url: event.url, name: event.name, error: event.error ? event.error.message : undefined };
            if (event.newDocument)
                params.newDocument = { request: networkDispatchers_1.RequestDispatcher.fromNullable(this._scope, event.newDocument.request || null) };
            this._dispatchEvent('navigated', params);
        });
    }
    static from(scope, frame) {
        const result = dispatcher_1.existingDispatcher(frame);
        return result || new FrameDispatcher(scope, frame);
    }
    async goto(params) {
        return { response: dispatcher_1.lookupNullableDispatcher(await this._frame.goto(params.url, params)) };
    }
    async waitForNavigation(params) {
        return { response: dispatcher_1.lookupNullableDispatcher(await this._frame.waitForNavigation(params)) };
    }
    async frameElement() {
        return { element: new elementHandlerDispatcher_1.ElementHandleDispatcher(this._scope, await this._frame.frameElement()) };
    }
    async evaluateExpression(params) {
        return { value: jsHandleDispatcher_1.serializeResult(await this._frame._evaluateExpression(params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg))) };
    }
    async evaluateExpressionHandle(params) {
        return { handle: elementHandlerDispatcher_1.createHandle(this._scope, await this._frame._evaluateExpressionHandle(params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg))) };
    }
    async waitForSelector(params) {
        return { element: elementHandlerDispatcher_1.ElementHandleDispatcher.createNullable(this._scope, await this._frame.waitForSelector(params.selector, params)) };
    }
    async dispatchEvent(params) {
        return this._frame.dispatchEvent(params.selector, params.type, jsHandleDispatcher_1.parseArgument(params.eventInit), params);
    }
    async evalOnSelector(params) {
        return { value: jsHandleDispatcher_1.serializeResult(await this._frame._$evalExpression(params.selector, params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg))) };
    }
    async evalOnSelectorAll(params) {
        return { value: jsHandleDispatcher_1.serializeResult(await this._frame._$$evalExpression(params.selector, params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg))) };
    }
    async querySelector(params) {
        return { element: elementHandlerDispatcher_1.ElementHandleDispatcher.createNullable(this._scope, await this._frame.$(params.selector)) };
    }
    async querySelectorAll(params) {
        const elements = await this._frame.$$(params.selector);
        return { elements: elements.map(e => new elementHandlerDispatcher_1.ElementHandleDispatcher(this._scope, e)) };
    }
    async content() {
        return { value: await this._frame.content() };
    }
    async setContent(params) {
        await this._frame.setContent(params.html, params);
    }
    async addScriptTag(params) {
        return { element: new elementHandlerDispatcher_1.ElementHandleDispatcher(this._scope, await this._frame.addScriptTag(params)) };
    }
    async addStyleTag(params) {
        return { element: new elementHandlerDispatcher_1.ElementHandleDispatcher(this._scope, await this._frame.addStyleTag(params)) };
    }
    async click(params) {
        await this._frame.click(params.selector, params);
    }
    async dblclick(params) {
        await this._frame.dblclick(params.selector, params);
    }
    async fill(params) {
        await this._frame.fill(params.selector, params.value, params);
    }
    async focus(params) {
        await this._frame.focus(params.selector, params);
    }
    async textContent(params) {
        const value = await this._frame.textContent(params.selector, params);
        return { value: value === null ? undefined : value };
    }
    async innerText(params) {
        return { value: await this._frame.innerText(params.selector, params) };
    }
    async innerHTML(params) {
        return { value: await this._frame.innerHTML(params.selector, params) };
    }
    async getAttribute(params) {
        const value = await this._frame.getAttribute(params.selector, params.name, params);
        return { value: value === null ? undefined : value };
    }
    async hover(params) {
        await this._frame.hover(params.selector, params);
    }
    async selectOption(params) {
        return { values: await this._frame.selectOption(params.selector, elementHandlerDispatcher_1.convertSelectOptionValues(params.elements, params.options), params) };
    }
    async setInputFiles(params) {
        await this._frame.setInputFiles(params.selector, elementHandlerDispatcher_1.convertInputFiles(params.files), params);
    }
    async type(params) {
        await this._frame.type(params.selector, params.text, params);
    }
    async press(params) {
        await this._frame.press(params.selector, params.key, params);
    }
    async check(params) {
        await this._frame.check(params.selector, params);
    }
    async uncheck(params) {
        await this._frame.uncheck(params.selector, params);
    }
    async waitForFunction(params) {
        const options = {
            ...params,
            polling: params.pollingInterval === undefined ? 'raf' : params.pollingInterval
        };
        return { handle: elementHandlerDispatcher_1.createHandle(this._scope, await this._frame._waitForFunctionExpression(params.expression, params.isFunction, jsHandleDispatcher_1.parseArgument(params.arg), options)) };
    }
    async title() {
        return { value: await this._frame.title() };
    }
}
exports.FrameDispatcher = FrameDispatcher;
//# sourceMappingURL=frameDispatcher.js.map