"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RouteDispatcher = exports.ResponseDispatcher = exports.RequestDispatcher = void 0;
const dispatcher_1 = require("./dispatcher");
const frameDispatcher_1 = require("./frameDispatcher");
const converters_1 = require("../../converters");
class RequestDispatcher extends dispatcher_1.Dispatcher {
    static from(scope, request) {
        const result = dispatcher_1.existingDispatcher(request);
        return result || new RequestDispatcher(scope, request);
    }
    static fromNullable(scope, request) {
        return request ? RequestDispatcher.from(scope, request) : undefined;
    }
    constructor(scope, request) {
        const postData = request.postDataBuffer();
        super(scope, request, 'Request', {
            frame: frameDispatcher_1.FrameDispatcher.from(scope, request.frame()),
            url: request.url(),
            resourceType: request.resourceType(),
            method: request.method(),
            postData: postData === null ? undefined : postData.toString('base64'),
            headers: converters_1.headersObjectToArray(request.headers()),
            isNavigationRequest: request.isNavigationRequest(),
            redirectedFrom: RequestDispatcher.fromNullable(scope, request.redirectedFrom()),
        });
    }
    async response() {
        return { response: dispatcher_1.lookupNullableDispatcher(await this._object.response()) };
    }
}
exports.RequestDispatcher = RequestDispatcher;
class ResponseDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, response) {
        super(scope, response, 'Response', {
            // TODO: responses in popups can point to non-reported requests.
            request: RequestDispatcher.from(scope, response.request()),
            url: response.url(),
            status: response.status(),
            statusText: response.statusText(),
            headers: converters_1.headersObjectToArray(response.headers()),
        });
    }
    async finished() {
        return await this._object._finishedPromise;
    }
    async body() {
        return { binary: (await this._object.body()).toString('base64') };
    }
}
exports.ResponseDispatcher = ResponseDispatcher;
class RouteDispatcher extends dispatcher_1.Dispatcher {
    constructor(scope, route) {
        super(scope, route, 'Route', {
            // Context route can point to a non-reported request.
            request: RequestDispatcher.from(scope, route.request())
        });
    }
    async continue(params) {
        await this._object.continue({
            method: params.method,
            headers: params.headers ? converters_1.headersArrayToObject(params.headers) : undefined,
            postData: params.postData ? Buffer.from(params.postData, 'base64') : undefined,
        });
    }
    async fulfill(params) {
        await this._object.fulfill({
            status: params.status,
            headers: params.headers ? converters_1.headersArrayToObject(params.headers) : undefined,
            body: params.isBase64 ? Buffer.from(params.body, 'base64') : params.body,
        });
    }
    async abort(params) {
        await this._object.abort(params.errorCode || 'failed');
    }
}
exports.RouteDispatcher = RouteDispatcher;
//# sourceMappingURL=networkDispatchers.js.map