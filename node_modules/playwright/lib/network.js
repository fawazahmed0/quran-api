"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeHeaders = exports.verifyHeaders = exports.STATUS_TEXTS = exports.Response = exports.Route = exports.Request = exports.rewriteCookies = exports.filterCookies = void 0;
const helper_1 = require("./helper");
const url_1 = require("url");
const converters_1 = require("./converters");
function filterCookies(cookies, urls) {
    const parsedURLs = urls.map(s => new URL(s));
    // Chromiums's cookies are missing sameSite when it is 'None'
    return cookies.filter(c => {
        if (!parsedURLs.length)
            return true;
        for (const parsedURL of parsedURLs) {
            if (parsedURL.hostname !== c.domain)
                continue;
            if (!parsedURL.pathname.startsWith(c.path))
                continue;
            if ((parsedURL.protocol === 'https:') !== c.secure)
                continue;
            return true;
        }
        return false;
    });
}
exports.filterCookies = filterCookies;
function rewriteCookies(cookies) {
    return cookies.map(c => {
        helper_1.assert(c.name, 'Cookie should have a name');
        helper_1.assert(c.value, 'Cookie should have a value');
        helper_1.assert(c.url || (c.domain && c.path), 'Cookie should have a url or a domain/path pair');
        helper_1.assert(!(c.url && c.domain), 'Cookie should have either url or domain');
        helper_1.assert(!(c.url && c.path), 'Cookie should have either url or domain');
        const copy = { ...c };
        if (copy.url) {
            helper_1.assert(copy.url !== 'about:blank', `Blank page can not have cookie "${c.name}"`);
            helper_1.assert(!copy.url.startsWith('data:'), `Data URL page can not have cookie "${c.name}"`);
            const url = new URL(copy.url);
            copy.domain = url.hostname;
            copy.path = url.pathname.substring(0, url.pathname.lastIndexOf('/') + 1);
            copy.secure = url.protocol === 'https:';
        }
        return copy;
    });
}
exports.rewriteCookies = rewriteCookies;
function stripFragmentFromUrl(url) {
    if (!url.indexOf('#'))
        return url;
    const parsed = new URL(url);
    parsed.hash = '';
    return parsed.href;
}
class Request {
    constructor(routeDelegate, frame, redirectedFrom, documentId, url, resourceType, method, postData, headers) {
        this._response = null;
        this._redirectedTo = null;
        this._failureText = null;
        this._waitForResponsePromiseCallback = () => { };
        helper_1.assert(!url.startsWith('data:'), 'Data urls should not fire requests');
        helper_1.assert(!(routeDelegate && redirectedFrom), 'Should not be able to intercept redirects');
        this._routeDelegate = routeDelegate;
        this._frame = frame;
        this._redirectedFrom = redirectedFrom;
        if (redirectedFrom)
            redirectedFrom._redirectedTo = this;
        this._documentId = documentId;
        this._url = stripFragmentFromUrl(url);
        this._resourceType = resourceType;
        this._method = method;
        this._postData = postData;
        this._headers = headers;
        this._waitForResponsePromise = new Promise(f => this._waitForResponsePromiseCallback = f);
        this._isFavicon = url.endsWith('/favicon.ico');
    }
    _setFailureText(failureText) {
        this._failureText = failureText;
        this._waitForResponsePromiseCallback(null);
    }
    url() {
        return this._url;
    }
    resourceType() {
        return this._resourceType;
    }
    method() {
        return this._method;
    }
    postData() {
        return this._postData ? this._postData.toString('utf8') : null;
    }
    postDataBuffer() {
        return this._postData;
    }
    postDataJSON() {
        const postData = this.postData();
        if (!postData)
            return null;
        const contentType = this.headers()['content-type'];
        if (!contentType)
            return null;
        if (contentType === 'application/x-www-form-urlencoded') {
            const entries = {};
            const parsed = new url_1.URLSearchParams(postData);
            for (const [k, v] of parsed.entries())
                entries[k] = v;
            return entries;
        }
        return JSON.parse(postData);
    }
    headers() {
        return { ...this._headers };
    }
    response() {
        return this._waitForResponsePromise;
    }
    _existingResponse() {
        return this._response;
    }
    _setResponse(response) {
        this._response = response;
        this._waitForResponsePromiseCallback(response);
    }
    _finalRequest() {
        return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
    }
    frame() {
        return this._frame;
    }
    isNavigationRequest() {
        return !!this._documentId;
    }
    redirectedFrom() {
        return this._redirectedFrom;
    }
    redirectedTo() {
        return this._redirectedTo;
    }
    failure() {
        if (this._failureText === null)
            return null;
        return {
            errorText: this._failureText
        };
    }
    _route() {
        if (!this._routeDelegate)
            return null;
        return new Route(this, this._routeDelegate);
    }
}
exports.Request = Request;
class Route {
    constructor(request, delegate) {
        this._handled = false;
        this._request = request;
        this._delegate = delegate;
    }
    request() {
        return this._request;
    }
    async abort(errorCode = 'failed') {
        helper_1.assert(!this._handled, 'Route is already handled!');
        this._handled = true;
        await this._delegate.abort(errorCode);
    }
    async fulfill(response) {
        helper_1.assert(!this._handled, 'Route is already handled!');
        this._handled = true;
        await this._delegate.fulfill(await converters_1.normalizeFulfillParameters(response));
    }
    async continue(overrides = {}) {
        helper_1.assert(!this._handled, 'Route is already handled!');
        await this._delegate.continue(converters_1.normalizeContinueOverrides(overrides));
    }
}
exports.Route = Route;
class Response {
    constructor(request, status, statusText, headers, getResponseBodyCallback) {
        this._contentPromise = null;
        this._finishedPromiseCallback = () => { };
        this._request = request;
        this._status = status;
        this._statusText = statusText;
        this._url = request.url();
        this._headers = headers;
        this._getResponseBodyCallback = getResponseBodyCallback;
        this._finishedPromise = new Promise(f => {
            this._finishedPromiseCallback = f;
        });
        this._request._setResponse(this);
    }
    _requestFinished(error) {
        this._finishedPromiseCallback({ error });
    }
    url() {
        return this._url;
    }
    ok() {
        return this._status === 0 || (this._status >= 200 && this._status <= 299);
    }
    status() {
        return this._status;
    }
    statusText() {
        return this._statusText;
    }
    headers() {
        return { ...this._headers };
    }
    finished() {
        return this._finishedPromise.then(({ error }) => error ? new Error(error) : null);
    }
    body() {
        if (!this._contentPromise) {
            this._contentPromise = this._finishedPromise.then(async ({ error }) => {
                if (error)
                    throw new Error(error);
                return this._getResponseBodyCallback();
            });
        }
        return this._contentPromise;
    }
    async text() {
        const content = await this.body();
        return content.toString('utf8');
    }
    async json() {
        const content = await this.text();
        return JSON.parse(content);
    }
    request() {
        return this._request;
    }
    frame() {
        return this._request.frame();
    }
}
exports.Response = Response;
// List taken from https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml with extra 306 and 418 codes.
exports.STATUS_TEXTS = {
    '100': 'Continue',
    '101': 'Switching Protocols',
    '102': 'Processing',
    '103': 'Early Hints',
    '200': 'OK',
    '201': 'Created',
    '202': 'Accepted',
    '203': 'Non-Authoritative Information',
    '204': 'No Content',
    '205': 'Reset Content',
    '206': 'Partial Content',
    '207': 'Multi-Status',
    '208': 'Already Reported',
    '226': 'IM Used',
    '300': 'Multiple Choices',
    '301': 'Moved Permanently',
    '302': 'Found',
    '303': 'See Other',
    '304': 'Not Modified',
    '305': 'Use Proxy',
    '306': 'Switch Proxy',
    '307': 'Temporary Redirect',
    '308': 'Permanent Redirect',
    '400': 'Bad Request',
    '401': 'Unauthorized',
    '402': 'Payment Required',
    '403': 'Forbidden',
    '404': 'Not Found',
    '405': 'Method Not Allowed',
    '406': 'Not Acceptable',
    '407': 'Proxy Authentication Required',
    '408': 'Request Timeout',
    '409': 'Conflict',
    '410': 'Gone',
    '411': 'Length Required',
    '412': 'Precondition Failed',
    '413': 'Payload Too Large',
    '414': 'URI Too Long',
    '415': 'Unsupported Media Type',
    '416': 'Range Not Satisfiable',
    '417': 'Expectation Failed',
    '418': 'I\'m a teapot',
    '421': 'Misdirected Request',
    '422': 'Unprocessable Entity',
    '423': 'Locked',
    '424': 'Failed Dependency',
    '425': 'Too Early',
    '426': 'Upgrade Required',
    '428': 'Precondition Required',
    '429': 'Too Many Requests',
    '431': 'Request Header Fields Too Large',
    '451': 'Unavailable For Legal Reasons',
    '500': 'Internal Server Error',
    '501': 'Not Implemented',
    '502': 'Bad Gateway',
    '503': 'Service Unavailable',
    '504': 'Gateway Timeout',
    '505': 'HTTP Version Not Supported',
    '506': 'Variant Also Negotiates',
    '507': 'Insufficient Storage',
    '508': 'Loop Detected',
    '510': 'Not Extended',
    '511': 'Network Authentication Required',
};
function verifyHeaders(headers) {
    const result = {};
    for (const key of Object.keys(headers)) {
        const value = headers[key];
        helper_1.assert(helper_1.helper.isString(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
        result[key] = value;
    }
    return result;
}
exports.verifyHeaders = verifyHeaders;
function mergeHeaders(headers) {
    const lowerCaseToValue = new Map();
    const lowerCaseToOriginalCase = new Map();
    for (const h of headers) {
        if (!h)
            continue;
        for (const key of Object.keys(h)) {
            const lower = key.toLowerCase();
            lowerCaseToOriginalCase.set(lower, key);
            lowerCaseToValue.set(lower, h[key]);
        }
    }
    const result = {};
    for (const [lower, value] of lowerCaseToValue)
        result[lowerCaseToOriginalCase.get(lower)] = value;
    return result;
}
exports.mergeHeaders = mergeHeaders;
//# sourceMappingURL=network.js.map